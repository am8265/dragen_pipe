import sys
import subprocess
from utilities import is_gzipped,fh
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import numpy as np


#######################################
###                                 ###
###  Script for binning GQ values   ###
###  from a gvcf file               ###
###  Author : Raghav                ###
#######################################


def gq_to_letter1(gq):
    
    """ Returns Letter encoding for gq value
        gq => numerical gq value
    """

    if(gq < 5):
        return 'a'
    elif(gq < 15):
        return 'b'
    elif(gq < 20):
        return 'c'
    elif(gq < 60):
        return 'd'
    else:
        return 'e'


def gq_to_letter2(gq):
    
    """ Returns Letter encoding for gq value
        gq => numerical gq value
    """

    if(gq < 5):
        return 'a'
    elif(gq < 20):
        return 'b'
    elif(gq < 60):
        return 'c'
    else:
        return 'd'

def bin_gq_to_letter(gq_val, gq_len):
    
    """ Return the printable form for the alpha-numeric gq bins
        i.e. gq_val = ['a','b','c'] gq_len = [200,300,500]
        200a,300b,500c is returned
        gq_val => a list of letter encoded gq values
        gq_len => a list of integers corresponding to the lengths of the
                        above letter encoded gq values
    """

    return_gq_string_list = []
    for c,l in zip(gq_val, gq_len):
        l = radix36_encoding(l)
        return_gq_string_list.append(l+c) 

    return ''.join(return_gq_string_list)


def update_gq_bins(n, gq, gq_len, gq_val):
    
    """ Update the coded gq values according to the letter encodings
        i.e. if n = 100 , gq = 'a' , gq_val = ['b','c','a'] and 
        gq_len = [100,200,200], the program will update the gq_len
        to [100,200,300] and gq_val to ['b','c','a']
        n => numerical value of gq
        gq => letter code for gq bin
        gq_len => list of numerical gq values seen in the current block
        gq_val => list of letter codes for gq bins seen in the current block
    """

    if(not gq_len):  # If list is empty
        gq_len.append(n)
        gq_val.append(gq)

    else:
        if(gq == gq_val[-1]):
            gq_len[-1] = gq_len[-1] + n
            
        else:
            gq_len.append(n)
            gq_val.append(gq)

    return [gq_len, gq_val]

def radix36_encoding(number):
    
    """ Call a bash script to do the base36 encoding
    number => numerical gq value in decimal
    returns base36 encoded value for the above
    Refer to : http://stackoverflow.com/questions/1181919/python-base-36-encoding
    """ 

    alphabet = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'

    if not isinstance(number, (int, long)):
        raise TypeError('number must be an integer')

    base36 = ''
    sign = ''

    if number < 0:
        sign = '-'
        number = -number

    if 0 <= number < len(alphabet):
        return sign + alphabet[number]

    while number != 0:
        number,i = divmod(number,len(alphabet))
        base36 = alphabet[i] + base36

    return str(sign + base36)
      

def radix36decode(number):
    """Decode the radix36 number to decimal
    """
    return int(number,36)


def main():
    """ Main Function """

    block = int(sys.argv[1])
    gvcf = sys.argv[2]
    sample_id = sys.argv[3]
    out_dir = sys.argv[4]
    
    IN = fh(gvcf)
    
    
    human_chromosomes = range(1,23)
    human_chromosomes = [str(x) for x in human_chromosomes]
    human_chromosomes.extend(['X','Y','MT'])
    prev_chromosome = '1'
    exclusion_str = radix36_encoding(block) + 'a'
    flag = 0
    
    bin_out = open(out_dir + sample_id + "_gq_binned_" +
                   str(block) + "_chr1.txt", 'w')


    gq_len = []
    gq_val = []


    run_len = []
    
    for line in IN:
        found = False
        line = line.strip('\n')
        if line[0] == '#': ## skip header
            continue
        
        contents = line.split('\t')
        check_site = contents[-2]
        gq_field = contents[-1]

        chromosome = contents[0]
        start = int(contents[1])
        

        temp_check = check_site.split(':')

        
        if chromosome not in human_chromosomes:
            continue ## Skip scaffolds

        
        if len(temp_check) == 5: ## Non Variant site
            gq = gq_field.split(':')[2]
            end = int(contents[7].strip('END='))
        else: ## Variant site
            for i in range(0,len(temp_check)):
                if temp_check[i] == 'GQ':
                    found = True
                    gq_id = i
                    break

            if found == True:
                gq = gq_field.split(':')[gq_id]
            else:
                gq = 0
                print line 
            end = start
            
            

        if prev_chromosome != chromosome:
            if gq_len : ## Account for remaining bins if present
                sum_length = sum(gq_len)
                if block - sum_length != 0: ## Make sure the block is filled 
                    update_gq_bins(
                        block - sum_length,'a',gq_len,gq_val)

                gq_str = bin_gq_to_letter(
                    gq_val,gq_len)

                if gq_str != exclusion_str:
                    bin_out.write("%s\t%s\t%s\n" % (
                        sample_id, str(out_start/block),gq_str))
                    run_len.append(len(gq_str))

            ## File handles are changed when chromosome changes 
            bin_out.close()
            bin_out = open(out_dir + sample_id + "_gq_binned_" +
                           str(block) + "_chr%s.txt" % chromosome, 'w')
            flag = 0

        if flag == 0:
            out_start = start - start % block 
            current_block = block
            gq_len = []
            gq_val = []
                

        current_interval = int(end) - int(start) + 1     
        current_gq = int(gq)

        gq_letter = gq_to_letter1(current_gq)


        if current_block - current_interval > 0:

            # Update block size
            current_block = current_block - current_interval
            n = current_interval
            gq_len,gq_val = update_gq_bins(
                n,gq_letter,gq_len,gq_val)

        elif current_block - current_interval == 0:
            n = current_interval
            gq_len,gq_val = update_gq_bins(
                n,gq_letter,gq_len,gq_val)
            gq_str = bin_gq_to_letter(
                gq_val,gq_len)
            if gq_str!= exclusion_str:
                bin_out.write("%s\t%s\t%s\n" %
                              (sample_id,str(out_start/block),gq_str))
                run_len.append(len(gq_str))
                ## Reinitialize key bariables
                out_start = out_start + block
                current_block  = block
                gq_len = []
                gq_val = []
                
        elif current_block - current_interval < 0:
            n = current_block
            gq_len,gq_val = update_gq_bins(
                n,gq_letter,gq_len,gq_val)

            gq_str = bin_gq_to_letter(
                gq_val,gq_len)

            if gq_str != exclusion_str:
                bin_out.write("%s\t%s\t%s\n" %
                              (sample_id,str(out_start/block),gq_str))
                run_len.append(len(gq_str))
            out_start = out_start + block

            remaining_interval = current_interval - current_block
            ## Reinitialize key variables
            current_block = block
            num_blocks = remaining_interval/block
            gq_len = []
            gq_val = []

            if(current_block - remaining_interval <= 0):
                remaining_interval = remaining_interval % current_block
                while(num_blocks > 0):
                    n = current_block
                    gq_len, gq_val = update_gq_bins(
                        n, gq_letter, gq_len, gq_val)
                    gq_str = bin_gq_to_letter(
                        gq_val, gq_len)
                    if(gq_str != exclusion_str):
                        bin_out.write("%s\t%s\t%s\n" % (
                            sample_id, str(out_start/B), gq_str))
                        run_len.append(len(gq_str))
                    num_blocks = num_blocks - 1

                    # Reinitialize key variables
                    gq_len = []
                    gq_val = []
                    out_start = out_start + block
                    current_block = block

                if(remaining_interval > 0):
                    n = remaining_interval
                    gq_len, gq_val = update_gq_bins(
                        n, gq_letter, gq_len, gq_val)
                    # Update block size
                    current_block = current_block - remaining_interval

                else:
                    n = remaining_interval
                    gq_len, gq_val = update_gq_bins(
                        n, gq_letter, gq_len, gq_val)
                    # Update block size
                    current_block = current_block - remaining_interval
                
    

        flag = 1
        # Store previous values
        prev_start = start
        prev_stop = end
        prev_chromosome = chromosome
        #print start,out_start
        
        
    if gq_len : ## Account for remaining bins if present
        # Add a's if the block is not fully spanned
        sum_length = sum(gq_len)
        if block - sum_length != 0:
            gq_len,gq_val = update_gq_bins(block - sum_length, 'a',
                                           gq_len,gq_val)

        gq_str = bin_gq_to_letter(gq_val,gq_len)
        if gq_str != exclusion_str:
            bin_out.write("%s\t%s\t%s\n"%
                          (sample_id,str(out_start/block),gq_str))           
            run_len.append(len(gq_str))
            
    IN.close()
    bin_out.close()


    plt.plot(np.arange(len(run_len)),run_len)
    plt.ylabel('GQ String Length')
    plt.xlabel('BlockID')
    plt.title('Encoded GQ String Lengths Across Different BlockIDs') 
    plt.savefig(sample_id+'.lengths.png')
    
if __name__ == "__main__":
    main()
